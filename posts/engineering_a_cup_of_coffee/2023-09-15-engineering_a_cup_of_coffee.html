<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>engineering_a_cup_of_coffee – A Chemical Engineer's Notebook</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-59228ce9c52eba116baca5d538563979.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #ffffff;
      }

      .quarto-title-block .quarto-title-banner {
        color: #ffffff;
background: url(../../images/pipes-unsplash-header.jpg);
      }
</style>
<style>
.quarto-title-block .quarto-title-banner {
  min-height: 100%;
  background-size: cover;
  box-shadow: inset 0 0 0 2000px rgba(0, 0, 0, 0.3);
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="A Chemical Engineer’s Notebook">
<meta property="og:description" content="A collection of notebooks about chemical engineering and analysis">
<meta property="og:image" content="https://aefarrell.github.io/images/engineering_coffee_files/Lockhart-control-chart.png">
<meta property="og:site_name" content="A Chemical Engineer's Notebook">
<meta property="og:image:alt" content="Coffee control chart">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">A Chemical Engineer’s Notebook</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> <i class="bi bi-info-circle" role="img">
</i> 
<span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> <i class="bi bi-wrench-adjustable-circle" role="img">
</i> 
<span class="menu-text">projects</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block"></header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="3">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#engineering-a-cup-of-coffee" id="toc-engineering-a-cup-of-coffee" class="nav-link active" data-scroll-target="#engineering-a-cup-of-coffee">Engineering a Cup of Coffee</a>
  <ul class="collapse">
  <li><a href="#extraction-and-the-coffee-control-chart" id="toc-extraction-and-the-coffee-control-chart" class="nav-link" data-scroll-target="#extraction-and-the-coffee-control-chart">Extraction and the Coffee Control Chart</a></li>
  <li><a href="#the-simplest-coffee-maker" id="toc-the-simplest-coffee-maker" class="nav-link" data-scroll-target="#the-simplest-coffee-maker">The simplest coffee maker</a>
  <ul class="collapse">
  <li><a href="#brew-temperature" id="toc-brew-temperature" class="nav-link" data-scroll-target="#brew-temperature">Brew temperature</a></li>
  <li><a href="#grind-size-and-uniformity" id="toc-grind-size-and-uniformity" class="nav-link" data-scroll-target="#grind-size-and-uniformity">Grind size and uniformity</a></li>
  <li><a href="#mixing-and-rate-constants" id="toc-mixing-and-rate-constants" class="nav-link" data-scroll-target="#mixing-and-rate-constants">Mixing and rate constants</a></li>
  <li><a href="#an-example-brew" id="toc-an-example-brew" class="nav-link" data-scroll-target="#an-example-brew">An example brew</a></li>
  </ul></li>
  <li><a href="#a-mass-transfer-model-of-coffee-brewing" id="toc-a-mass-transfer-model-of-coffee-brewing" class="nav-link" data-scroll-target="#a-mass-transfer-model-of-coffee-brewing">A mass transfer model of coffee brewing</a>
  <ul class="collapse">
  <li><a href="#the-dominant-rate" id="toc-the-dominant-rate" class="nav-link" data-scroll-target="#the-dominant-rate">The dominant rate</a></li>
  <li><a href="#boundary-conditions" id="toc-boundary-conditions" class="nav-link" data-scroll-target="#boundary-conditions">Boundary conditions</a></li>
  <li><a href="#the-carslaw-and-jaeger-model" id="toc-the-carslaw-and-jaeger-model" class="nav-link" data-scroll-target="#the-carslaw-and-jaeger-model">The Carslaw and Jaeger model</a></li>
  <li><a href="#packaging-the-final-result" id="toc-packaging-the-final-result" class="nav-link" data-scroll-target="#packaging-the-final-result">Packaging the final result</a></li>
  </ul></li>
  <li><a href="#final-thoughts" id="toc-final-thoughts" class="nav-link" data-scroll-target="#final-thoughts">Final thoughts</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">




<section id="engineering-a-cup-of-coffee" class="level1 page-columns page-full">
<h1>Engineering a Cup of Coffee</h1>
<p>While making coffee one day, I started thinking about how the coffee making process is both a perfect representation of the sorts of systems chemical engineers work on every day and also a weird edge case unlike most of the unit operations in the standard repertoire of process engineering.</p>
<p>Making coffee involves heat, mass, and momentum transfer across multiple phases – pretty standard stuff for undergraduate chemical engineering curricula. On the other hand, while industrial scale leaching operations are generally designed for maximum efficiency – removing the most amount of a substance with the least amount of solvent, energy, etc. – coffee makers are specifically designed to avoid that outcome. A saturated cup of coffee would be strong, harsh, and undrinkable. Coffee making, as a unit op, aims at a managed inefficiency, which makes for an interesting design case<a href="#fn-1" class="sidenote-number"></a><span id="fn-1" class="sidenote"> I am not the first person to think of this: using coffee as a basis for exploring engineering concepts is the entire premise of <a href="https://www.amazon.ca/gp/product/B09FSCDY18/">this book</a>. From the reviews it sounds like it is, essentially, a lab manual for exploring chemical engineering concepts using coffee.</span>.</p>
<section id="extraction-and-the-coffee-control-chart" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="extraction-and-the-coffee-control-chart">Extraction and the Coffee Control Chart</h2>
<p>I claimed that making coffee is, in a sense, a deliberately inefficient process. By this I mean the goal is not to maximize extraction – defined as the mass of solids dissolved in the final cup of coffee relative to the starting mass of coffee grounds – but instead to target some middle ground. This is largely because extraction is an imperfect measure of what we actually want. Coffee releases a whole slew of flavour compounds and a good cup of coffee is a balance of all of these. However we have both limited variables to control and limited knowledge of that final composition. Even simply measuring the total dissolved solids (TDS) with a refractometer puts one well into the stratospheric heights of coffee nerd-dom. Trying to monitor all of the relevant flavour compounds would require something like a quarter-million dollar GC-MS, well out of the reach of most coffee obsessives.</p>
<p>So extraction is really the best we have, as far as quantitative measures go, with the giant caveat that coffee with the same extraction, from the same beans, can taste quite different depending on the brew method. Using an indirect measurement for the actual process variable of interest is not too different from how a lot of unit operations are controlled, distillation, for example, often uses temperature as a proxy for the composition.</p>
<figure class="figure">
<img src="../../images/engineering_coffee_files/Lockhart-control-chart.png" alt="Coffee control chart" class="figure-img">
<figcaption>
The standard coffee control chart (<a href="#batali-2020">Batali, Ristenpart, and Guinard</a> “Brew Temperature,” fig.&nbsp;1.). <a href="https://creativecommons.org/licenses/by/4.0/">CC&nbsp;BY&nbsp;4.0</a>
</figcaption>
</figure>
<p>The standard way of thinking about coffee extraction starts with Lockhart’s <em>coffee control chart</em>, this plots the concentration of solids (TDS) against total extraction. The diagonal lines represent a given dose of coffee (I typically brew 55g/L with my V60, which puts me pretty near the sweet spot). A given brew moves along the diagonal line for the given dose, moving from the bottom left to the upper right as the brew proceeds. The goal is to stop the brew once the extraction and strength (concentration) have reached the optimal level<a href="#fn-2" class="sidenote-number"></a></p>
<p>{% capture footnote-2 %} For a given dose of coffee, the concentration and extraction are directly proportional to one another.</p>
<p><span class="math display">\[ \mathrm{Dose} = D = { m_{beans} \over V_{water} } \approx { m_{beans} \over V_{cup} } \]</span></p>
<p><span class="math display">\[ \mathrm{Extraction} = E = { m_{cup} \over m_{beans} } = { { c_{cup} V_{cup} } \over m_{beans} } \]</span></p>
<p><span class="math display">\[ c_{cup} = D \cdot E \]</span></p>
<p>where the subscript <em>cup</em> means the mass/volume that ends up in the final cup of coffee. This is only <em>approximately</em> the case as some water is absorbed into the coffee grounds. The amount of water retained in the coffee grounds can be accounted for, giving a more accurate measure of final extraction. {% endcapture %}</p>
<aside class="sidenote" id="fn-2">
{{ footnote-2 | markdownify }}
</aside>
<p>For industrial scale distillation, absorption, extraction, leaching, etc. the process is usually modeled as a series of equilibrium stages, and the whole point is to maximize extraction and concentration. This leads to designs for counter-current solids extractors such as a Rotocel extractor or a <a href="https://www.youtube.com/watch?v=myxqWLB5WIA">Bollman extractor</a></p>
<figure class="figure">
<img src="../../images/engineering_coffee_files/Rotocel-Extractor.png" alt="Rotocel extractor extractor" class="figure-img">
<figcaption>
A Rotocel extractor, you are unlikely to see one of these at your local coffee shop.
</figcaption>
</figure>
<p>Extractors like this are, in fact, how one might <em>decaffeinate</em> coffee. In that case one does want to maximize the extraction of caffeine, and is free to adjust several parameters such as the solvent (with options such as supercritical CO<sub>2</sub>, dichloromethane, or ethyl acetate) that are otherwise pretty fixed for normal coffee making. At the end of the day a cup of coffee has to be made with water, a steaming cup of dichloromethane just won’t cut it.</p>
<p>Coffee makers inhabit a space where the design parameters are highly restricted. Outside of espresso, the machine has to operate at atmospheric pressure and temperatures achievable with a normal kettle. The solvent must be water. The process is likely batch or semi-batch<a href="#fn-3" class="sidenote-number"></a><span id="fn-3" class="sidenote">I would love to see a fully continuous coffee maker, like the fully continuous industrial operations, and there is no reason why you couldn’t make one. Imagine going into your local coffee shop and seeing a glass fluidized bed continuously circulating grounds and hot water, that would be pretty groovy.</span>. The extraction happens fully within the mass-transfer dominated regime, specifically avoiding reaching equilibrium (the fundamental design assumption in most industrial extractors) as that leads to over-extracted coffee.</p>
</section>
<section id="the-simplest-coffee-maker" class="level2">
<h2 class="anchored" data-anchor-id="the-simplest-coffee-maker">The simplest coffee maker</h2>
<p>Perhaps the simplest method for making coffee is to put coffee grounds and water in a vessel, add heat, and let it steep for a while. This is, for example, how <a href="https://www.youtube.com/watch?v=2rbpghXKPv0">Turkish coffee</a> is made as well as qahwa, bunna, and many others. A <a href="https://www.youtube.com/watch?v=st571DYYTR8">French press</a> and other infusion brewers are a very similar idea except that the water is also the source of heat, and the pot is left to steep without any additional heat input. That’s not the only difference, of course, they differ quite substantially in grind size, whether or not the grounds are strained out at the end, and in the addition of spices or sugar during the brew. But for the purposes of building a simple model all of these methods are vessels in which coffee steeps in hot water. There are three main process variables that impact coffee extraction, and taste, for a given set of beans: brew temperature, grind size, and brew time.</p>
<p>In some ways this makes these methods some of the easier ways to make good coffee. Dialing in grind size and temperature is reasonably straight forward and once set remain constant. The remaining variable, time, is relatively easy to adjust: simply wait longer.</p>
<p>Modeling extraction is fairly straight forward, after some basic assumptions are made: that the brew is isothermal, that the ground coffee is uniform and with constant dimensions, and that the liquid phase is well mixed. All of these assumptions are wrong to some degree, and how wrong they are will ultimately govern how useful this model is.</p>
<section id="brew-temperature" class="level3">
<h3 class="anchored" data-anchor-id="brew-temperature">Brew temperature</h3>
<p>Brew temperature is an obvious variable to change, though it has wide ranging impacts and parsing out what exactly changing the temperature <em>does</em> is not obvious. Firstly, the solubility of the various compounds extracted from the beans is a function of temperature and in general solubility is difficult to predict, but broadly speaking solutes are more soluble at higher temperatures. Coffee is <em>more extractable</em> at higher temperatures. However the coffee matrix is complex and there are more than just two phases involved: flavour compounds in the coffee will partition between the solid matrix, coffee oils, and the water at different proportions depending upon the temperature. This is perhaps what is behind the notable difference in taste between cold brew versus a hot immersion brew. Even when made with the same beans, and to the same concentration, the flavour profile of cold brew is quite different<a href="#fn-4" class="sidenote-number"></a><span id="fn-4" class="sidenote"><a href="#batali-2022">Batali et al</a>, <em>Foods.</em> 11, no. 16: 2440</span>. That said, over the range of temperatures used to brew a French press, this may not be very important<a href="#fn-5" class="sidenote-number"></a><span id="fn-5" class="sidenote"><a href="#batali-2020">Batali, Ristenpart, and Guinard</a> <em>Scientific Reports.</em> 10: 16450</span>.</p>
<p>Secondly, brew temperature impacts the <em>rate</em> of extraction. Generally speaking, diffusion coefficients are proportional to (absolute) temperature, $ T$ <a href="#fn-6" class="sidenote-number"></a><span id="fn-6" class="sidenote"><a href="#schwartzberg-1987">Schwartzberg</a>, “Leaching – Organic Materials,” 558; <a href="#poling-2001">Poling, Prausnitz, and O’Connell</a>, <em>The Properties of Gases and Liquids</em>, 11.21-11.33.</span>. At higher temperatures the various flavour compounds will diffuse more quickly through the grounds and also through the coffee, thus making the brew faster.</p>
<p>To make modeling extraction simpler, we assume the brew temperature is <em>constant</em>. This means that, whatever the relative solubilities or rate constants turn out to be, they are constant with respect to time. The only thing varying over time is the concentration of coffee solubles in water and remaining in the grounds. For something like Turkish coffee, the system is probably close to isothermal as it is continuously heated and will remain at or near the boiling point of water the entire time. For a French press this is less true, as the press will lose heat to the environment. How much heat is lost over the course of the brew is going to depend strongly upon the press and the environment it is in. My French press is a double walled stainless steel carafe <a href="https://www.bodum.com/ca/en/1308-16-bodum-columbia">like this one</a> and likely loses much less heat than a more typical glass carafe. It is also important to consider whether or not the French press is pre-heated. If not, the brew temperature is not going to be the temperature of the kettle. The carafe has significant thermal mass, especially if it is glass, and it will absorb a lot of heat out of the water over the course of the brew (in addition to losing heat to the environment).</p>
<p>Suppose my French press starts off at 95°C and cools to 75°C – a sizable loss of heat – how much impact would that have on extraction rate? Since $ T$, the percent change in the rate constant is equal to the percent change in (absolute) temperature</p>
<p><span class="math display">\[ { { \Delta \mathscr{D} } \over \mathscr{D} } = { { \Delta T } \over T } \]</span></p>
<pre><code>ΔT = 20
T = 368.15
ΔT / T = 0.054325682466385986</code></pre>
<p>Even over this significant loss of heat, that translates to only a 5.4% change in the rate constants. To the exacting standards of a coffee nerd that may seem like a lot, but to chemical engineer that is really not much, it justifies the isothermal assumption (at least as a first approximation).</p>
</section>
<section id="grind-size-and-uniformity" class="level3">
<h3 class="anchored" data-anchor-id="grind-size-and-uniformity">Grind size and uniformity</h3>
<p>Grind size is important if only for being where most of your money can get sunk when building out your home coffee set-up. A good grinder is not cheap, and a bad grinder leads to truly bad coffee. In this case what you are chasing is the ability to tune the average grind size as well as the uniformity of the size of particles produced by the grinder. A good grinder can reliably produce a consistent and suitably narrow particle size distribution.</p>
<p>Why does grind size matter at all? The grind size determines the available surface area of the coffee. Mass transfer from the coffee beans (grounds) to the water is proportional to the surface area of coffee exposed to water, and so changing the grind size directly impacts the rate of extraction. The direct impact of grind-size is typically quantified through the <em>specific area</em>, <em>a<sub>v</sub></em>, which is the surface area of the particle per unit volume. For a sphere this is</p>
<p><span class="math display">\[ a_v = {S \over V} = { {4 \pi b^2} \over { \frac{4}{3} \pi b^3} } = {3 \over b} \]</span></p>
<p>where <em>b</em> is the radius of the particle. This leads immediately to the observation that, for the same dose of coffee, a finer grind leads to larger overall surface area and thus a faster rate of extraction. It also hints at why a uniform particle size distribution is important: a smaller particle has proportionately more surface area and will experience faster extraction than a larger particle, leading to the smallest particles (the fines) being <em>over extracted</em> while the largest particles (the boulders) are <em>under extracted</em>.</p>
<p>Of course coffee grounds are not perfect spheres, they have a complex shape arising from the combination of cutting and brittle fracture that characterize the grinding process. The standard engineering approach is to assume that they are spheres anyways, since that is a simpler geometry to work with, and adjust for the non-sphericity with some sort of shape factor or other parameter. In the case of mass and heat transfer, typically that is the <a href="https://en.wikipedia.org/wiki/Sauter_mean_diameter">Sauter mean diameter</a> (or Sauter mean radius), which is essentially the average diameter of the distribution of spheres that would have the same specific area as the actual particles. For an individual particle the Sauter radius is</p>
<p><span class="math display">\[ b_{s} = {3 \over a_v } \]</span></p>
<p>It is important to note, though, that the following model is developed for spheres and only works as well as the grounds can be approximated as spheres.</p>
</section>
<section id="mixing-and-rate-constants" class="level3">
<h3 class="anchored" data-anchor-id="mixing-and-rate-constants">Mixing and rate constants</h3>
<p>Mass transfer problems, like this one, ultimately come down to finding good rate constants. They can be measured, estimated from a correlation, or simply tabulated in a reference, but regardless the model is only as good as the rate constants. The rate constants define, to some extent, the model itself and govern one of the key brew variables: brew time.</p>
<p>In the case of coffee, and organic materials in general, there is a complex micro-scale geometry involving multiple phases: the solid ground itself, coffee oils, and water. The coffee will diffuse from the solid into the oils, into water in the interstitial spaces, and also out into the bulk liquid. All of these processes have potentially different rate constants. Additionally the solid phase is not structurally homogeneous, it is a complex arrangement of coffee bean cells, voids, pores and such. Building a model to incorporate all of this complexity is certainly possible<a href="#fn-7" class="sidenote-number"></a><span id="fn-7" class="sidenote"><a href="#moroney-2015">Moroney et al</a>, <em>Chemical Engineering Science.</em> 137: 216-234.</span> but the standard approach is to treat this as a two-phase problem where all of the complexity of the solid phase, the <a href="https://www.merriam-webster.com/dictionary/marc">marc</a>, and any secondary phases (e.g.&nbsp;coffee oils) are all averaged together into one pseudo-homogeneous solid phase and the solvent (water) forms the liquid phase. This approximation leaves us with two mass transfer rates: the diffusion through the (pseudo-homogeneous) solid phase, within the coffee particles, and the diffusion through the solvent phase, the water outside of the coffee particles. At the interface, the solute leaves the solid phase and enters the liquid phase.</p>
<p>For organic material with hard cell walls the relative diffusivity of the solid phase to the liquid phase generally falls along the range $ = 0.1-0.2$ <a href="#fn-8" class="sidenote-number"></a><span id="fn-8" class="sidenote"><a href="#schwartzberg-1987">Schwartzberg</a>, “Leaching – Organic Materials,” 557.</span>, this allows us to estimate the (effective) diffusivity within the solid based on measured diffusivities in liquid water. It also tells us that diffusion through the solid is 5-10× slower than in the liquid phase and so, depending upon the geometry of the problem, diffusion through the solid phase may be the governing rate.</p>
<p>Diffusion through the liquid phase is complicated by mixing. The diffusivity used above is the diffusivity in quiescent liquid water. In practice, in the brew vessel, the liquid will be moving and convective mass transfer will be very significant. Usually for mass transfer problems this is all rolled up into a mass transfer coefficient <em>h</em> which combines all of the flow complexity and geometry of the problem into a single coefficient. This is then typically estimated using correlations for the <a href="https://en.wikipedia.org/wiki/Sherwood_number">Sherwood number</a>.</p>
<p>The interface between the solid and liquid phase introduces a complication as there is some partitioning between the phases happening at the interface. If there wasn’t coffee couldn’t be made. A critical piece of the model is assuming a relationship between the concentration immediately on the solid side of the interface and the concentration immediately on the liquid side of the interface. For organic leaching it is typical to assume linear equilibrium with an equilibrium distribution coefficient</p>
<p><span class="math display">\[ K = \frac{ q^{*} }{ c^{*} } \]</span></p>
<p>Where <em>q</em> is the concentration of solute in the solid phase and <em>c</em> is the concentration of solute in the liquid phase. This is equivalent to assuming that there are two first order processes happening</p>
<p><span class="math display">\[ \mathrm{coffee}_{s} \xrightarrow{k_1} \mathrm{coffee}_{l} \]</span></p>
<p><span class="math display">\[ \mathrm{coffee}_{l} \xrightarrow{k_2} \mathrm{coffee}_{s} \]</span></p>
<p>At equilibrium the rates of these two processes are equal</p>
<p><span class="math display">\[ k_1 q^{*} = k_2 c^{*} \Leftrightarrow \frac{k_2}{k_1} = \frac{ q^{*} }{ c^{*} } = {K} \]</span></p>
<p>Typically one assumes that at the interface, in the infintesimally thin slice of liquid on one side and the infintesimally thin slice of solid on the other, the solute is always at equilibrium (this is not the same as assuming the <em>system</em> is at equilibrium)</p>
</section>
<section id="an-example-brew" class="level3">
<h3 class="anchored" data-anchor-id="an-example-brew">An example brew</h3>
<p>At this point we can start defining what our specific brew is going to be: roast, grind size, dose, and water temperature. From this we can work to estimate the necessary parameters, such as the equilibrium constant, solid and liquid phase diffusivities. To an extent, these parameters then govern what specific model is used to model the brew.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># properties of the coffee grounds</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># equilibrium parameters</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Moroney et al. 2015</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>q_sat <span class="op">=</span> <span class="fl">118.95</span> <span class="co"># kg/m³</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>c_sat <span class="op">=</span> <span class="fl">212.4</span> <span class="co"># kg/m³</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> q_sat<span class="op">/</span>c_sat</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># effective diffusivity</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Moroney et al. 2015; Schwartzberg 1987, 557</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>𝒟ₗ <span class="op">=</span> <span class="fl">2.2e-9</span> <span class="co"># m²/s</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>𝒟ₛ <span class="op">=</span> <span class="fl">0.1</span><span class="op">*</span>𝒟ₗ</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># particle size</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Moroney et al. 2015</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="fl">569.45e-6</span> <span class="co"># m</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co"># density, medium roast</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Rodrigues et al. 2002, 8</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>ρₛ <span class="op">=</span> <span class="fl">314.0</span> <span class="co"># kg/m³</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co"># dose</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co"># assumed, 22.5g in 500mL</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>mₛ <span class="op">=</span> <span class="fl">0.0225</span>  <span class="co"># kg</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>Vₛ <span class="op">=</span> mₛ<span class="op">/</span>ρₛ  <span class="co"># m³</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>Vₗ <span class="op">=</span> <span class="fl">500e-6</span> <span class="co"># m³</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># properties of the water</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># density</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Poling et al. 2007, 2-103</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>MW <span class="op">=</span> <span class="fl">18.015</span> <span class="co">#kg/kmol</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ρₗ</span>(T)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    τ <span class="op">=</span> <span class="fl">1</span> <span class="op">-</span> T<span class="op">/</span><span class="fl">647.096</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    mol_dens <span class="op">=</span> <span class="fl">17.863</span> <span class="op">+</span> <span class="fl">58.606</span><span class="op">*</span>τ<span class="op">^</span><span class="fl">0.35</span> <span class="op">-</span> <span class="fl">95.396</span><span class="op">*</span>τ<span class="op">^</span>(<span class="fl">2</span><span class="op">/</span><span class="fl">3</span>) <span class="op">+</span> <span class="fl">213.89</span><span class="op">*</span>τ <span class="op">-</span> <span class="fl">141.26</span><span class="op">*</span>τ<span class="op">^</span>(<span class="fl">4</span><span class="op">/</span><span class="fl">3</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mol_dens<span class="op">*</span>MW</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># viscosity</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Poling et al. 2007, 2-432</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="fu">μₗ</span>(T) <span class="op">=</span> <span class="fu">exp</span>(<span class="op">-</span><span class="fl">52.843</span> <span class="op">+</span> <span class="fl">3703.6</span><span class="op">/</span>T <span class="op">+</span> <span class="fl">5.866</span><span class="fu">*log</span>(T) <span class="op">-</span> <span class="fl">5.879e-29</span><span class="op">*</span>T<span class="op">^</span><span class="fl">10</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="fu">νₗ</span>(T) <span class="op">=</span> <span class="fu">μₗ</span>(T)<span class="op">/</span><span class="fu">ρₗ</span>(T)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># brew temperature</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co"># assumed, 95°C</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>Tₗ <span class="op">=</span> <span class="fl">95</span><span class="op">+</span><span class="fl">273.15</span> <span class="co">#K</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># initial concentration</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>c₀ <span class="op">=</span> <span class="fl">0.0</span> <span class="co"># kg/m³</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co"># final (max) concentration</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>c_max <span class="op">=</span> <span class="fu">min</span>(q_sat<span class="op">*</span>Vₛ<span class="op">/</span>Vₗ <span class="op">+</span> c₀, c_sat) <span class="co"># kg/m³</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These are a lot of parameters and I think it is good practice to think about how to organize them into a <code>struct</code>. In this case I define an <code>InfusionBrew</code> struct to store all of the parameters necessary for defining the brew recipe for an infusion brewer.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> InfusionBrew{T}</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    K<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    q_max<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    c_max<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    Vₗ<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    Vₛ<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    mₛ<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    𝒟ₛ<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    𝒟ₗ<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    b<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>brew <span class="op">=</span> <span class="fu">InfusionBrew</span>(K,q_sat,c_max,Vₗ,Vₛ,mₛ,𝒟ₛ,𝒟ₗ,b);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="a-mass-transfer-model-of-coffee-brewing" class="level2">
<h2 class="anchored" data-anchor-id="a-mass-transfer-model-of-coffee-brewing">A mass transfer model of coffee brewing</h2>
<p>Pulling together all of the information we have collected about coffee we can build a partial differential equation to describe the brewing process, making the following assumptions:</p>
<ul>
<li>The system is isothermal with brew temperature <em>T<sub>l</sub></em></li>
<li>Coffee grounds are spherical and have constant radius <em>b</em></li>
<li>The coffee matrix is a pseudo-homogeneous solid, diffusion through the solid follows <a href="https://en.wikipedia.org/wiki/Fick%27s_laws_of_diffusion#Fick's_second_law">Fick’s second law</a> with diffusivity <span class="math inline">\(\mathscr{D}_s\)</span> and diffusion is only relevant in the radial direction <em>r</em></li>
<li>The liquid phase is well mixed, i.e.&nbsp;the bulk concentration <em>c</em> is spatially homogeneous and is only a function of time</li>
<li>Mass transfer into the liquid phase occurs through a <em>thin film</em> with a mass transfer coefficient <em>h</em></li>
<li>At the interface between the thin film and the solid coffee, the concentration of solubles is in equilibrium with equilibrium constant <em>K</em></li>
</ul>
<p>We can visualize this set-up with three “phases”, the bulk liquid, a thin film around the coffee particle, and the pseudo-homogeneous solid coffee particle itself. Coffee is extracted from the particles into the thin film and from the thin film into the bulk liquid.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../images/engineering_coffee_files/Coffee_Mass_Transfer.svg" class="img-fluid figure-img"></p>
<figcaption>svg</figcaption>
</figure>
</div>
<p>There are two rates important processes governing the extraction of coffee:</p>
<ol type="1">
<li>Diffusion across the interface into the thin film, governed by <a href="https://en.wikipedia.org/wiki/Fick%27s_laws_of_diffusion#Fick's_first_law">Fick’s first law</a></li>
<li>Transfer from the thin film into the bulk liquid</li>
</ol>
<p>Starting with (1) the mass flux into the thin film is given by <a href="https://en.wikipedia.org/wiki/Fick%27s_laws_of_diffusion#Fick's_first_law">Fick’s first law</a> (in spherical coordinates)</p>
<p><span class="math display">\[ J_1 = - \mathscr{D}_s \left( { \partial q } \over { \partial r} \right)_{r=b} \]</span></p>
<p>Of course the concentration in the solid, <em>q</em>, is a function of time (as more is extracted, there less left behind), which is given by <a href="https://en.wikipedia.org/wiki/Fick%27s_laws_of_diffusion#Fick's_second_law">Fick’s second law</a> (in spherical coordinates)</p>
<p><span class="math display">\[ { {\partial q} \over {\partial t} } = \frac{1}{r^2} { \partial \over {\partial r} } \left( r^2 \mathscr{D}_s { {\partial q} \over {\partial r} } \right) \]</span></p>
<p>Turning to (2) the mass flux from the thin film into the bulk liquid is given by</p>
<p><span class="math display">\[ J_2 = - h \left( c - c_s \right) \]</span></p>
<p>Where <em>c</em> is the concentration in the bulk liquid and <em>c<sub>s</sub></em> is the concentration at the surface.</p>
<p>The change in concentration in the bulk liquid with respect to time can also be written in terms of a mass balance on the liquid phase:</p>
<p><span class="math display">\[ V_l { { \partial c} \over {\partial t} } = a_v V_s J_2  = \frac{3}{b} V_s J_2 \]</span></p>
<p><span class="math display">\[ { { \partial c} \over {\partial t} } = \frac{3}{b} \frac{V_s}{V_l} J_2 \]</span></p>
<p>The solution to this partial differential equation depends upon which of these mass transfer processes, (1) or (2), is dominant.</p>
<section id="the-dominant-rate" class="level3">
<h3 class="anchored" data-anchor-id="the-dominant-rate">The dominant rate</h3>
<p>The standard approach to solving this problem is to look at the limiting cases, where the <a href="https://en.wikipedia.org/wiki/Biot_number#Mass_transfer_analogue">Biot number</a> is either very large or very small<a href="#fn-9" class="sidenote-number"></a><span id="fn-9" class="sidenote"><a href="#seader-2011">Seader, Henley and Roper</a>, <em>Separation Process Principles</em>, 663.</span></p>
<ul>
<li><em>Bi</em> &lt; 0.001 : the mass transfer through the film dominates, a simple exponential model is appropriate</li>
<li>0.001 &lt; <em>Bi</em> &lt; 200 : use an intermediate method<a href="#fn-10" class="sidenote-number"></a><span class="sidenote" id="fn-10">The intermediate solution is not given in <a href="#seader-2011">Seader</a>, only a reference: Schwartzberg, Henry G. and R. Y. Chao. 1982. “Solute Diffusivities in Leaching Processes.” <em>Food Technology</em>. 36, no. 2: 73-86, which has not been digitized and is not available from my local library, so I have no idea what it says ¯\_(ツ)_/¯</span></li>
<li><em>Bi</em> &gt; 200 : the mass transfer through the coffee particles dominates, the more complicated solution from Carslaw and Jaeger is best</li>
</ul>
<p>I will argue in a very hand-wavy way that the Biot number for mass transfer is likely to be large, and so the model from <a href="#carslaw-1959">Carslaw and Jaeger</a><a href="#fn-11" class="sidenote-number"></a><span id="fn-11" class="sidenote"><a href="#carslaw-1959">Carslaw and Jaeger</a>, <em>Conduction of Heat in Solids</em>, 240-241.</span> is the probably the best model. First let’s start with Biot number for mass transfer, which for this situation is<a href="#fn-12" class="sidenote-number"></a><span id="fn-12" class="sidenote"><a href="#seader-2011">Seader, Henley and Roper</a>, <em>Separation Process Principles</em>, 663.</span></p>
<p><span class="math display">\[ \mathrm{Bi} = { {h b} \over {K \mathscr{D}_s} } = {\mathscr{D}_l \over \mathscr{D}_s} { \mathrm{Sh} \over K }\]</span></p>
<p>Where <em>Sh</em> is the <a href="https://en.wikipedia.org/wiki/Sherwood_number">Sherwood number</a>, defined as</p>
<p><span class="math display">\[ \mathrm{Sh} = { {h b} \over \mathscr{D}_l } \]</span></p>
<p>Defining the Biot number in terms of the Sherwood number might, at first glance, not seem tremendously useful. However, if we suppose the Froessling equation<a name="fnref-13" href="#fn-13" class="sidenote-number"></a><span id="fn-13" class="sidenote"><a href="#hottel-2008">Hottel et al</a>, “Heat and Mass Transfer,” 5-69.</span> for flow past a single sphere applies</p>
<p><span class="math display">\[ \mathrm{Sh} = 2 + 0.552 \mathrm{Re}^{1/2} \mathrm{Sc}^{1/3} \]</span></p>
<p>with <em>Re</em> the <a href="https://en.wikipedia.org/wiki/Reynolds_number">Reynold’s number</a> and <em>Sc</em> the <a href="https://en.wikipedia.org/wiki/Schmidt_number">Schmidt number</a>, then we have a correlation for the Biot number as a function of the Reynold’s number.</p>
<p><span class="math display">\[ \mathrm{Bi} = {\mathscr{D}_l \over \mathscr{D}_s} { 1 \over K } \left( 2 + 0.552 \mathrm{Re}^{1/2} \mathrm{Sc}^{1/3} \right) \]</span></p>
<p><span class="math display">\[ \mathrm{Bi} = { 20 \over K } + { 5.52 \over K } \mathrm{Re}^{1/2} \mathrm{Sc}^{1/3} \]</span></p>
<p>Where <span class="math inline">\({\mathscr{D}_s \over \mathscr{D}_l}\)</span> = 0.1 is assumed from Schwartzberg<a href="#fn-14" class="sidenote-number"></a><span id="fn-14" class="sidenote"><a href="#schwartzberg-1987">Schwartzberg</a>, “Leaching – Organic Materials,” 557.</span>. The Schmidt number, <em>Sc</em>, and equilibrium constant, <em>K</em>, can be calculated</p>
<pre><code>Sc = νₗ(Tₗ) / 𝒟ₗ = 139.98370415887905
K = q_sat / c_sat = 0.5600282485875706

Bi = 35.7124842370744 + 51.178588534736114 √Re</code></pre>
<p>Under this model, any flow with <em>Re</em> &gt; 10.3 corresponds to <em>Bi</em> &gt; 200, which occurs when the velocity is</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>Re <span class="op">=</span> <span class="fl">10.3</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> <span class="fu">Re*νₗ</span>(Tₗ)<span class="op">/</span>b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.005570341094459917</code></pre>
<p>that is 5.6mm/s, a velocity so small that it may be achieved through the natural convection occurring within a French press (and especially so in the case of something heated from below like Turkish coffee), but is certainly the case when the French press is stirred.</p>
<p>Regardless it is unlikely that <span class="math inline">\(\mathrm{Bi}&lt;0.001\)</span> and thus the simple exponential model is probably not a good fit, we turn instead to the model from <a href="#carslaw-1959">Carslaw and Jaeger</a>.</p>
</section>
<section id="boundary-conditions" class="level3">
<h3 class="anchored" data-anchor-id="boundary-conditions">Boundary conditions</h3>
<p>In the above I casually disregarded boundary conditions, focusing instead on refining the model. Before we move forward we should take a moment to clarify what the boundary conditions are.</p>
<p>First off the coffee starts with a set of initial concentrations <em>q<sub>0</sub></em> and <em>c<sub>0</sub></em>, usually these would be the max concentration in the solid phase and zero respectively but they don’t have to be. By disregarding the transfer through the thin film we impose another boundary condition: that at <em>r = b</em> the solid-phase concentration is at equilibrium with the concentration in the bulk liquid <em>q<sub>r=b</sub> = K c</em></p>
<ul>
<li><em>t = 0</em> : <em>q = q<sub>0</sub></em> and <em>c = c<sub>0</sub></em></li>
<li><em>r = b</em> : <em>q = K c</em></li>
<li><em>r = 0</em> : <em>q</em> is finite</li>
</ul>
</section>
<section id="the-carslaw-and-jaeger-model" class="level3">
<h3 class="anchored" data-anchor-id="the-carslaw-and-jaeger-model">The Carslaw and Jaeger model</h3>
<p>It might, at first glance, appear that I have lost the thread, <a href="#carslaw-1959">Carslaw and Jaeger</a> is a book on heat transfer, this is a mass transfer problem. This is an example of the unreasonable effectiveness of treating transport phenomena as a unified subject. By putting the PDE into dimensionless form we find that the PDE for the equivalent heat transfer problem (a solid sphere cooling in a liquid) has already been solved and we can just use that answer.</p>
<p>First step, to put the PDE in dimensionless form we make the substitutions:</p>
<p><span class="math display">\[ \xi = {r \over b} \]</span></p>
<p><span class="math display">\[ \tau = { {\mathscr{D}_s t} \over b^2} \]</span></p>
<p><span class="math display">\[ u = { { q - q^{*} } \over { q_0 - q^{*} } }\]</span></p>
<p><span class="math display">\[ u_f = { {c - c^{*} } \over { c_0 - c^{*} } }\]</span></p>
<p>After which the PDE becomes</p>
<p><span class="math display">\[ { {\partial u} \over {\partial \tau} } = \frac{1}{\xi^2} { \partial \over {\partial \xi} } \left( \xi^2 {\partial \over {\partial \xi} } \right) \]</span></p>
<p>With boundary conditions</p>
<ul>
<li><em>τ = 0</em> : <em>u = 0</em></li>
<li><em>ξ = 1</em> : <em>u = u<sub>f</sub></em></li>
<li><em>ξ = 0</em> : <em>u</em> is finite</li>
</ul>
<p>And the mass transfer into the liquid bulk becomes</p>
<p><span class="math display">\[ { {\partial u_f} \over {\partial \tau} } = -\frac{3}{\alpha} \left. { {\partial u} \over {\partial \xi} } \right|_{\xi=1} \]</span></p>
<p>With $ = { V_l } $ and boundary condition</p>
<ul>
<li><em>τ = 0</em> : <em>u<sub>f</sub></em> = 1</li>
</ul>
<p>This is the equivalent PDE (in dimensionless form) to the heat transfer case for a hot solid sphere cooling in a well mixed fluid<a href="#fn-15" class="sidenote-number"></a><span id="fn-15" class="sidenote"><a href="#carslaw-1959">Carslaw and Jaeger</a>, <em>Conduction of Heat in Solids</em>, 240-241; <a href="#bird-2007">Bird, Stewart and Lightfoot</a>, <em>Transport Phenomena</em>, 379-381.</span>, with the solution</p>
<p><span class="math display">\[ u_f = 6α (α+1) \sum_{k=1}^{\infty} { \exp(-τ x_k^2 )\over { 9(α+1) + (α x_k)^2 } } \]</span></p>
<p>Where the <em>x<sub>k</sub></em> s are the roots of the equation</p>
<p><span class="math display">\[ \tan(x) = { {3 x} \over { 3 + \alpha x^2 } } \]</span></p>
<p>(the particular form shown here comes from <a href="#schwartzberg-1987">Schwartzberg</a>)</p>
<p>The first problem, when actually using this solution, is generating the roots of the equation. The original equation has a repeated singularity and, in my experience, off-the-shelf root finding algorithms have trouble with that and will find spurious zeros in the vicinity of the singularities.</p>
<p>A better approach is to re-write it in a different way</p>
<p><span class="math display">\[ \tan(x) = { \sin(x) \over \cos(x) } \]</span></p>
<p><span class="math display">\[ \tan(x) - { {3 x} \over { 3 + \alpha x^2 } } = 0 \Leftrightarrow \left( 3 + \alpha x^2 \right) \sin(x) - 3 x \cos(x) = 0 \]</span></p>
<p>This latter form is nice and continuous, with no singularities.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">IntervalRootFinding</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Roots</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>α <span class="op">=</span> Vₗ<span class="op">/</span>(K<span class="op">*</span>Vₛ)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="fu">f</span>(x) <span class="op">=</span> <span class="fu">tan</span>(x) <span class="op">-</span> <span class="fl">3</span>x<span class="op">/</span>(<span class="fl">3</span><span class="op">+</span>α<span class="op">*</span>x<span class="op">^</span><span class="fl">2</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="fu">g</span>(x) <span class="op">=</span> (<span class="fl">3</span> <span class="op">+</span> α<span class="op">*</span>x<span class="op">^</span><span class="fl">2</span>)<span class="fu">*sin</span>(x) <span class="op">-</span> <span class="fl">3</span><span class="fu">x*cos</span>(x)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co"># find the first 5 roots</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>k<span class="op">=</span><span class="fl">5</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>xk <span class="op">=</span> <span class="fu">find_zeros</span>(g, <span class="fl">0</span>, (k<span class="op">+</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>)<span class="op">*</span><span class="cn">π</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>6-element Vector{Float64}:
  0.0
  3.214656575481129
  6.321030394109289
  9.45018248676156
 12.585470558898335
 15.723260568418107</code></pre>
<figure class="figure">
<img src="../../images/engineering_coffee_files/output_24_0.svg" alt="Plot of the functions f(x) and g(x) showing the locations of the roots" class="figure-img">
<figcaption>
The roots of the equations <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(g(x)\)</span>, note the repeated singularities in <span class="math inline">\(f(x)\)</span>.
</figcaption>
</figure>
<p>Since <em>α</em> is fixed for a given problem we will end up using the same roots over and over again, so it would be nice to pre-calculate those roots. However, at this point, we don’t know how many we will need to get a reasonable answer. So my approach is to calculate as many as we need dynamically: if we need more roots than have already been calculated, calculate those ones and append them to the list of already calculated roots.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">getroots</span>(n)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">≤</span> <span class="fu">length</span>(xk)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> xk[<span class="fl">2</span><span class="op">:</span>n]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        new_roots <span class="op">=</span> <span class="fu">find_zeros</span>(x <span class="op">-&gt;</span> <span class="fu">g</span>(x), xk[<span class="kw">end</span>], (n<span class="op">+</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>)<span class="op">*</span><span class="cn">π</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">append!</span>(xk, new_roots)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> xk[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>]</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The standard approach to calculating an infinite series is to use <a href="https://en.wikipedia.org/wiki/Richardson_extrapolation">Richardson extrapolation</a> as this accelerates convergence and allows for an error estimate.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Richardson</span>:extrapolate</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">u_f</span>(τ)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    val, err <span class="op">=</span> <span class="fu">extrapolate</span>(<span class="fl">1</span>, x0<span class="op">=</span><span class="cn">Inf</span>) <span class="cf">do</span> N</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                xk <span class="op">=</span> <span class="fu">getroots</span>(<span class="fu">Int</span>(N))</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                <span class="fl">6</span><span class="fu">α*</span>(α<span class="op">+</span><span class="fl">1</span>)<span class="fu">*sum</span>( <span class="fu">exp</span>.(<span class="op">-</span>τ<span class="op">.*</span>(xk<span class="op">.^</span><span class="fl">2</span>))<span class="op">./</span>((<span class="fl">9</span><span class="fu">*</span>(α<span class="op">+</span><span class="fl">1</span>))<span class="op">.+</span>(α<span class="op">.*</span>xk)<span class="op">.^</span><span class="fl">2</span>) )</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> val</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we can put together a bulk concentration function</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">c</span>(t)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    τ <span class="op">=</span> (𝒟ₛ<span class="op">*</span>t)<span class="op">/</span>b<span class="op">^</span><span class="fl">2</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> (c₀ <span class="op">-</span> c_max)<span class="fu">*u_f</span>(τ) <span class="op">+</span> c_max</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<figure class="figure">
<img src="../../images/engineering_coffee_files/output_31_0.svg" alt="Plot showing the concentration of solubles in the extract as a function of time" class="figure-img">
<figcaption>
The concentration of solubles in the extract over time.
</figcaption>
</figure>
<p>Extraction is simply concentration over dose</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">extraction</span>(t) <span class="op">=</span> <span class="fu">c</span>(t)<span class="op">*</span>Vₗ<span class="op">/</span>mₛ</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<figure class="figure">
<img src="../../images/engineering_coffee_files/output_34_0.svg" alt="Plot showing the extraction of coffee as a function of time" class="figure-img">
<figcaption>
The extraction of coffee solubles over time.
</figcaption>
</figure>
</section>
<section id="packaging-the-final-result" class="level3">
<h3 class="anchored" data-anchor-id="packaging-the-final-result">Packaging the final result</h3>
<p>At this point we have enough to put together a <code>struct</code> to contain the parameters needed for the Carslaw and Jaeger model</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> CarslawSolution{T}</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    α<span class="op">::</span><span class="dt">T</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    τ₁<span class="op">::</span><span class="dt">T</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    xk<span class="op">::</span><span class="dt">Vector{T}</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    ib<span class="op">::</span><span class="dt">InfusionBrew{T}</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">CarslawSolution</span>(ib<span class="op">::</span><span class="dt">InfusionBrew</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    α  <span class="op">=</span> ib.Vₗ<span class="op">/</span>(ib.K<span class="op">*</span>ib.Vₛ)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    τ₁ <span class="op">=</span> ib.𝒟ₛ<span class="op">/</span>ib.b<span class="op">^</span><span class="fl">2</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    xk <span class="op">=</span> <span class="fu">find_zeros</span>( x <span class="op">-&gt;</span> (<span class="fl">3</span> <span class="op">+</span> α<span class="op">*</span>x<span class="op">^</span><span class="fl">2</span>)<span class="fu">*sin</span>(x) <span class="op">-</span> <span class="fl">3</span><span class="fu">x*cos</span>(x) , <span class="fl">0</span>, (<span class="fl">10.5</span>)<span class="op">*</span><span class="cn">π</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">CarslawSolution</span>(α, τ₁, xk, ib)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>and update our code to add some methods for calculating the concentration and extraction based on a Carslaw and Jaeger model for the infusion brew.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">getroots</span>(n, model<span class="op">::</span><span class="dt">CarslawSolution</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">≤</span> <span class="fu">length</span>(model.xk)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> model.xk[<span class="fl">2</span><span class="op">:</span>n]</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        new_roots <span class="op">=</span> <span class="fu">find_zeros</span>(x <span class="op">-&gt;</span> (<span class="fl">3</span> <span class="op">+</span> model.α<span class="op">*</span>x<span class="op">^</span><span class="fl">2</span>)<span class="fu">*sin</span>(x) <span class="op">-</span> <span class="fl">3</span><span class="fu">x*cos</span>(x),</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>                               model.xk[<span class="kw">end</span>], (n<span class="op">+</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>)<span class="op">*</span><span class="cn">π</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">append!</span>(model.xk, new_roots)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> model.xk[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>]</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">c</span>(t, model<span class="op">::</span><span class="dt">CarslawSolution</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    τ <span class="op">=</span> model.τ₁<span class="op">*</span>t</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    α <span class="op">=</span> model.α</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    u_f, err <span class="op">=</span> <span class="fu">extrapolate</span>(<span class="fl">1</span>, x0<span class="op">=</span><span class="cn">Inf</span>) <span class="cf">do</span> N</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>                  xk <span class="op">=</span> <span class="fu">getroots</span>(<span class="fu">Int</span>(N), model)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>                  <span class="fl">6</span><span class="fu">α*</span>(α<span class="op">+</span><span class="fl">1</span>)<span class="fu">*sum</span>( <span class="fu">exp</span>.(<span class="op">-</span>τ<span class="op">.*</span>(xk<span class="op">.^</span><span class="fl">2</span>))<span class="op">./</span>((<span class="fl">9</span><span class="fu">*</span>(α<span class="op">+</span><span class="fl">1</span>))<span class="op">.+</span>(α<span class="op">.*</span>xk)<span class="op">.^</span><span class="fl">2</span>) )</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>               <span class="cf">end</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> (c₀ <span class="op">-</span> c_max)<span class="op">*</span>u_f <span class="op">+</span> c_max</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="fu">extraction</span>(t, model<span class="op">::</span><span class="dt">CarslawSolution</span>) <span class="op">=</span> <span class="fu">c</span>(t, model)<span class="op">*</span>model.ib.Vₗ<span class="op">/</span>model.ib.mₛ</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> <span class="fu">CarslawSolution</span>(brew);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The advantage of packaging code like this is that is now easy to explore the impact of changes to individual parameters, for example below is the impact that changing grind size has on the extraction curve. It follows our general intuition that smaller grind sizes extract faster. It also shows a major weakness of this model: there is only one particle size in the model, which is average over the range of actual particle sizes. This model works well if the grind is quite uniform, however if there is a wide range of particle sizes the actual coffee will be a mix of over extracted coffee (from the small particles) and under extracted coffee (from the large particles).</p>
<figure class="figure">
<img src="../../images/engineering_coffee_files/output_41_0.svg" alt="Plot showing multiple extraction curves for a range of grind sizes" class="figure-img">
<figcaption>
The evolution of coffee extraction over time for several grind sizes. Note that the smallest grind sizes extract faster, achieving equilibrium, whereas the largest grind sizes extract more slowly.
</figcaption>
</figure>
</section>
</section>
<section id="final-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="final-thoughts">Final thoughts</h2>
<p>I think this shows that making coffee can be an interesting exploration of how one would go about building a mass-transfer model for an extraction operation, and going through the stages of simplifying the model by, for example, assuming simpler geometries, limiting cases and such. I think you could also take this as an example of how <em>very often</em> chasing down appropriate model parameters is the limiting step when building an engineering model (at least in chemical engineering). Often the exact chemical process that you want to model has not been explored, experimentally, over the entire range of your process variables (if at all).</p>
<p>The next obvious step with this model is to build some datasets and fit some of these models to actual observed extractions. This could be a jumping off point for exploring how changes in different parameters impact the overall extraction or required brew time.</p>
<p>For a complete listing of code used to generate data and figures, please see the <a href="https://github.com/aefarrell/aefarrell.github.io/blob/main/_notebooks/2023-09-15-engineering_a_cup_of_coffee.ipynb">corresponding julia notebook</a> {: .notice–info}</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ul>
<li><a name="batali-2022">Batali</a>, Mackenzie E., Lik Xian Lim, Jiexin Liang, Sara E. Yeager, Ashley N. Thompson, Juliet Han, William D. Ristenpart, and Jean-Xavier Guinard. “Sensory Analysis of Full Immersion Coffee: Cold Brew Is More Floral, and Less Bitter, Sour, and Rubbery Than Hot Brew.” <em>Foods</em>. 11, no. 16 (2022): 2440 <a href="https://doi.org/10.3390/foods11162440">doi:10.3390/foods11162440</a> <a href="https://www.researchgate.net/publication/362703498">ResearchGate</a></li>
<li><a name="batali-2020">Batali</a>, Mackenzie E., William D. Ristenpart and Jean‑Xavier Guinard. “Brew temperature, at fixed brew strength and extraction, has little impact on the sensory profile of drip brew coffee.” <em>Scientific Reports</em>. 10 (2020): 16450 <a href="https://doi.org/10.1038/s41598-020-73341-4">doi:10.1038/s41598-020-73341-4</a> <a href="https://www.researchgate.net/publication/345315113">ResearchGate</a></li>
<li><a name="bird-2007">Bird</a>, R. Byron, Warren E. Stewart, Edwin N. Lightfoot. <em>Transport Phenomena</em>. 2nd ed.&nbsp;Hoboken: John Wiley &amp; Sons, 2007. <a href="https://archive.org/details/transportphenome0000bird_n8h5">archive</a></li>
<li><a name="carslaw-1959">Carslaw</a>, Horatio S. and John C. Jaeger. <em>Conduction of Heat in Solids</em>. 2nd ed.&nbsp;London: Oxford University Press, 1959. <a href="https://archive.org/details/conductionofheat0000hsca_w2d9">archive</a></li>
<li><a name="hottel-2008">Hottel</a>, Hoyt C., James J. Noble, Adel F. Sarofim, Geoffrey D. Silcox, Phillip C. Wankat, Kent S. Knaebel. “Heat and Mass Transfer” in <em>Perry’s Chemical Engineers’ Handbook</em>, 8th ed.&nbsp;Edited by Don W. Green, New York: McGraw Hill, 2008.</li>
<li><a name="moroney-2015">Moroney</a>, Kevin M., William T. Lee, Stephen B. G. O’Brien, Freek Suijver and Johan Marra. “Modelling of coffee extraction during brewing using multiscale methods: An experimentally validated model.” <em>Chemical Engineering Science</em>. 137 (2015): 216-234 <a href="https://doi.org/10.1016/j.ces.2015.06.003">doi:10.1016/j.ces.2015.06.003</a> <a href="https://www.researchgate.net/publication/282622621_Modelling_of_coffee_extraction_during_brewing_using_multiscale_methods_An_experimentally_validated_model">ResearchGate</a></li>
<li><a name="poling-2001">Poling</a>, Bruce E., John M. Prausnitz and John P. O’Connell. <em>The Properties of Gases and Liquids</em>. 5th ed.&nbsp;New York: McGraw Hill, 2001.</li>
<li><a name="poling-2007">Poling</a>, Bruce E., George H. Thomson, Daniel G. Friend, Richard L. Rowley and W. Vincent Wilding. “Physical and Chemical Data” in <em>Perry’s Chemical Engineers’ Handbook</em>. 8th ed.&nbsp;Edited by Don W. Green, New York: McGraw Hill, 2007.</li>
<li><a name="rodrigues-2003">Rodrigues</a>, Melissa A. A., Maria Lúcia A. Borges, Adriana S. Franca, Leandro S. Oliveira and Paulo C. Corrêa. “Evaluation of Physical Properties of Coffee During Roasting.” <em>Agricultural Engineering International: the CIGR Journal of Scientific Research and Development</em>. V (2003) <a href="https://www.researchgate.net/publication/267858074">ResearchGate</a></li>
<li><a name="schwartzberg-1987">Schwartzberg, Henry G.</a> “Leaching – Organic Materials” in <em>Handbook of Seperation Process Technology,</em> Edited by Ronald W. Rousseau, Hoboken: John Wiley &amp; Sons, 1987.</li>
<li><a name="seader-2011">Seader</a>, J. D., Ernest J. Henley and D. Keith Roper. <em>Separation Process Principles</em>. 3rd ed.&nbsp;Hoboken: John Wiley &amp; Sons, 2011. <a href="https://archive.org/details/separationproces0000sead_z6e6">archive</a></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/aefarrell\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="aefarrell/aefarrell.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>